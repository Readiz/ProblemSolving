#include <stdio.h>
#define MEMO_MAX 100000
int main() {
    int T;
    scanf("%d", &T);
    for (int tc = 0; tc < T; tc++) {
        // // int memo[MEMO_MAX] = { 0, 1, 2, 4, 6, 9, 12, 16, };
        // int oldOne = 1;
        // for (int i = 1; i < 100; i++) {
        //     int newOne = 1;
        //     if(i >= 2) {
        //         newOne = oldOne + ((i + 1) / 2);
        //     }
        //     oldOne = newOne;
        //     printf("%d ", newOne);
        // }
        int x, y, diff;
        scanf("%d %d", &x, &y);
        diff = y - x;
        int oldOne = 1;
        for (int i = 1; i < MEMO_MAX; i++) {
            int newOne = 1;
            if(i >= 2) {
                newOne = oldOne + ((i + 1) / 2);
            }
            oldOne = newOne;
            if (newOne >= diff) {
                printf("%d\n", i);
                break;
            }
        }
    }
    return 0;
}

/*
가장 적게 공간이동 하려면 당연히 가속을 풀로 땡기다가, 서서히 감속해야 할 것.
그리고 직전에는 k = 1이 되어야 하고..
그러면 요런 형태임
1 2 3 4 5 6 5 4 3 2 1 ... => 이 최대값보다 적은 횟수로.. 갈 수 있는 요런 느낌
그럼 요 형태의 배열을 가지고 있으면 될 듯...? (최대거리가 되는거니)

공간이동 장치 발동 수에 따른 max 거리
1: 1                => 1   (  1) <- (i + 1) / 2 의 값
2: 1 1              => 2  ( + 1)
3: 1 2 1            => 4  ( + 2)
4: 1 2 2 1          => 6  ( + 2)
5: 1 2 3 2 1        => 9  ( + 3)
6: 1 2 3 3 2 1      => 12 ( + 3)
7: 1 2 3 4 3 2 1    => 16 ( + 4)

이걸 규칙대로 찍어보면:
1 2 4 6 9 12 16 20 25 30 36 42 49 56 64 72 81 90 100 110 121 132 144 156 169 182 196 210 225 240 256 272 289 306 324 342 361 380 400 420 441 462 484 506 529 552 576 600 625 650 676 702 729 756 784 812 841 870 900 930 961 992 1024 1056 1089 1122 1156 1190 1225 1260 1296 1332 1369 1406 1444 1482 1521 1560 1600 1640 1681 1722 1764 1806 1849 1892 1936 1980 2025 2070 2116 2162 2209 2256 2304 2352 2401 2450 2500

홀수 수열
1 4 9 16 25 36 49 64 81 ...
짝수 수열
2 6 12 20 30 42 56 72 90 ...

*/
